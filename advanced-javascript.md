
<!-- TOC GitLab -->

+ [JavaScript 高级程序设计的笔记](#javascript-高级程序设计的笔记)
	* [JavaScript 历史](#javascript-历史)
	* [在 HTML 中使用 javascript](#在-html-中使用-javascript)
		- [`<script>` 属性介绍](#script-属性介绍)
		- [使用 `<script>`](#使用-script)
			+ [嵌入式](#嵌入式)
			+ [外部链接 javascript](#外部链接-javascript)
			+ [浏览器的解释顺序](#浏览器的解释顺序)
			+ [文档类型 `DOCTYPE`](#文档类型-doctype)
			+ [使用 `<noscript>` 标签](#使用-noscript-标签)
	* [基本概念](#基本概念)
		- [注意事项](#注意事项)
		- [数据类型](#数据类型)
			+ [检测数据类型](#检测数据类型)
			+ [underfined 类型](#underfined-类型)
			+ [null 类型](#null-类型)
			+ [Boolean 类型](#boolean-类型)
			+ [Number 类型](#number-类型)
			+ [string 类型](#string-类型)
			+ [Object 类型](#object-类型)
		- [操作符](#操作符)
		- [语句](#语句)
		- [函数](#函数)
			+ [定义一个函数](#定义一个函数)
			+ [理解函数的参数](#理解函数的参数)
	* [变量、作用域和内存问题](#变量作用域和内存问题)
		- [基本类型和引用类型的值](#基本类型和引用类型的值)
		- [复制变量值](#复制变量值)
		- [函数传递参数](#函数传递参数)
		- [检测值类型](#检测值类型)
		- [变量的作用域问题](#变量的作用域问题)
			+ [作用域链的概念](#作用域链的概念)
			+ [延长作用链](#延长作用链)
			+ [Js 不存在块级作用域](#js-不存在块级作用域)
		- [垃圾收集机制](#垃圾收集机制)
			+ [如何识别“不再使用”](#如何识别不再使用)
			+ [个人怎么管理内存](#个人怎么管理内存)
	* [引用类型](#引用类型)
		- [Object 类型](#object-类型-1)
			+ [创建一个对象](#创建一个对象)
			+ [对象的属性的访问](#对象的属性的访问)
		- [Array 类型](#array-类型)
			+ [创建一个数组](#创建一个数组)
			+ [检测数组类型](#检测数组类型)
			+ [转换方法](#转换方法)
			+ [数组的一些方法](#数组的一些方法)
		- [Date 类型](#date-类型)
			+ [创建 Date 类型](#创建-date-类型)
			+ [静态方法](#静态方法)
			+ [继承来的方法](#继承来的方法)
			+ [日期的格式化方法](#日期的格式化方法)
			+ [获得设置日期的组件方法](#获得设置日期的组件方法)
		- [RegExp 类型](#regexp-类型)
			+ [创建正则表达式](#创建正则表达式)
			+ [属性](#属性)
			+ [实例方法](#实例方法)
			+ [继承方法](#继承方法)
		- [function 类型](#function-类型)
			+ [创建函数对象](#创建函数对象)
			+ [函数对象的属性](#函数对象的属性)
			+ [函数对象方法](#函数对象方法)

<!-- /TOC -->


# JavaScript 高级程序设计的笔记

## JavaScript 历史

pass

## 在 HTML 中使用 javascript

### `<script>` 属性介绍

- `async`，异步脚本，表示立即下载脚本，但不应妨碍页面中的其他操作；
- `charset`, 很少用，用于指定代码使用的字符集；
- `defer`, 延迟脚本，表示脚本可以延迟到文档完全被解析和显示之后再执行；
- `language`, 已废弃；
- `type`, 指定 MIME 类型，默认使用的值是 `application/x-javascript`, 设置这个值可能导致脚本被忽略；
- `src`, 指定源文件地址。

### 使用 `<script>`

使用 `script` 标签主要有两种方法：**嵌入式** 和 **外部式**。

#### 嵌入式

直接在标签内部加入代码。

注意代码中不能出现 `</script>` 字符串，浏览器加载时会认为这是代码的结束标志。可以使用 `<\/script>` 来进行转义操作，避免错误。

HTML5 中规定，嵌入式的 JavaScript 不能使用 defer 和 async 属性。

#### 外部链接 javascript

使用 src 属性指定文件地址，不能在标签内部插入任何代码。和嵌入式代码是水火不相容的，只能选择使用一个。

- 使用 延迟脚本
```javascript
<script src="index.js" defer="defer"></script>	
```

- 使用 异步脚本
```javascript
<script src="index.js" async></script>	
```

使用外部脚本的好处：
- 便于维护；
- 缓存，多个页面使用同一个 js 可以只下载一次；
- 使用于未来，方便从 HTML 升级到 Xhtml。

#### 浏览器的解释顺序

- 首先，执行 js 代码时，网页的内容加载暂停；
- 大原则是：**顺序执行**，按照标签位置的顺序执行；
- 延迟执行脚本：脚本延迟到整个页面都解析完毕之后再运行。

	当存在多个延迟脚本时，HTML5 规定按顺序执行，并且先于`DOMContentLoaded` 事件执行。但实际情况则不是按顺序执行，并且也不会先于事件触发。因此建议只包含一个延迟脚本。

- 异步执行脚本：告诉浏览器立即执行脚本，并且不妨碍页面中其他操作。

  异步脚本一定会在页面的 `load` 事件前执行，但不一定会在 `DOMContentLoaded` 之前执行。多个异步脚本不一定按照先后顺序执行。


#### 文档类型 `DOCTYPE`
文档类型主要分为两种：混杂式和严格式。

混杂式会让 IE 的行为与 IE5 相同，标准模式会让 IE 更接近标准行为。主要影响 CSS 的呈现行为。

HTML5 使用 `<!DOCTYPE html>` 默认是标准模式。

#### 使用 `<noscript>` 标签
用于处理浏览器默认不支持 js 脚本的行为。

当浏览器不支持 js 或者禁用 js 时，会显示整个标签内部的 HTML 内容。

## 基本概念
### 注意事项
- 区分大小写；
- 标识符，就是函数名的格式要求；
- 严格模式，`"use strict"`;
- 关键字和保留字。使用关键字会引起 `Identifier Expected` 错误；
- 变量，全局变量和局部变量。

### 数据类型
有六种基本的数据类型：

`underfined, null, Boolean, Number, String, Object`

#### 检测数据类型
`typeof `操作符，检测结果如下：

| 类型         | 结果         |
|--------------|--------------|
| underfined   | 'underfined' |
| Boolean      | 'boolean'    |
| String       | 'string'     |
| Number       | 'number'     |
| Object, null | 'object'     |
| function     | 'function'   |

单独的列出了函数的检测结果。六种基本数据类型当中的 null 合并到 object 中了，因为 null 本身就是一个空对象指针。

#### underfined 类型
注意变量未初始化的结果是 underfined 类型。

使用 typeof 检测未声明的变量时仍然会显示 underfined 类型，注意区分。

#### null 类型
一定注意，null 是一个**空对象指针**。

一般定义一个变量准备保存对象时，最好首先将其初始化为 null。这样，可以直接检测 null 值就可以判断这个变量是否已经保存了一个对象的引用。

#### Boolean 类型
区分大小写，只有小写才表示正常的真，假值。

转型函数 `Boolean()`:

| 数据类型   | 真值       | 假值   |
|------------|------------|--------|
| string     | 非空字符串 | 空     |
| number     | 非零       | 0和NaN |
| object     | 任何对象   | null   |
| underfined | 没有       | 本身   |

#### Number 类型
ECMAScript 使用 IEEE754（二进制浮点数计算标准）保存所有的数字类型为浮点数，采用64位双精度的格式。其中，0-51位表示数字，52-62表示指数，代表小数点的位置，63位是正负号的位置。因此，小数的最高精度是17位。

- [ ] 17位有效数字的详细原因。

[数字在JavaScript中是如何编译的](https://segmentfault.com/a/1190000014867071) 

著名的问题：
> 0.1+0.2!=0.3 

这是因为 0.1 和 0.2 都不能完全的化简为二进制，然后相加后也没办法化简。在最高精度内存在数字，因此，JS 不认为这个结果和 0.3 相等。这是采用 IEEE754 标准的所有语言的问题。

```javascript
0.1+0.2
0.30000000000000004
```

十进制和二进制小数的转换，负数的转换。

存储单位：64位(bit) = 8 字节(byte), 1 KB=1024 byte. 说的汉字属于宽字符，双字节的，就是这个意思。

- 浮点数，浮点数的占用内存是整数值的两倍，所以 JS 会自动的转为整数；
- 数值范围，存在一个 `Infinity, -Infinity` 范围，可以使用 `Number.MIN_VALUE` 属性查看，可以使用 `isFinte()` 来判断一个数是否在有效范围内，是返回真。
- NaN，not a number, 表示本该返回数值的操作结果并未返回数值的情况。任何数除以 0 就会出现这种结果。任何设计 Nan 的计算结果都是 NaN, NaN 与任何值都不相等，包括本身。

	可以使用 `isNaN()` 函数来判断是不是正确数值。可以传入字符串（思考一下结果），对象（思考一下过程）。

---
*一个比较重要的问题: 数值转换问题* 

| `Number()`                     | `parseInt()`                           | `parseFloat()`   |
|--------------------------------|----------------------------------------|------------------|
| 多种类型                       | 仅限于字符串                           | 仅限于字符串     |
| 识别正负号，小数点，和空字符串 | 只识别以数字开头的字符串，不支持小数点 | 改进，支持小数点 |

`number()` 函数在多种类型时的处理：

| 数值类型                          | 结果           |
|-----------------------------------|----------------|
| boolean                           | 1,0            |
| number                            | 简单的传入传出 |
| null                              | 0              |
| underfined                        | NaN            |
| string                            |                |
| -- 正负号，小数点，进制，空字符串 | 正常识别       |
| -- 有不认识的，`12bule`           | NaN            |
| Object                            | 正常对象的处理 |

`parseInt()` 函数的特点：

**工作机制**：从字符串开头开始，忽略开头的空格，如果开头第一个非空字符不是数字或者正负号，直接返回 NaN。如果找到第一个数字，就会继续向后找，直至不是数字为止。

一个例子，`123 1blue` 返回 123，不会去掉空格，不会识别字母，不是数字直接退出。

不识别小数点。

可以提供第二个参数, 作为进制的指示，可以传入一个 Number 数值，表明返回结果的进制。

`parseFloat()` 函数：

改进版的 `parseInt()`, 识别小数了。只识别第一个小数点。

不支持基数(就是第二个参数)。另外，输入也只支持十进制，十六进制为返回0。

#### string 类型
1. 字符字面量，就是一些特殊的字符。

| 字面量 | 含义         |
|--------|--------------|
| \n     |              |
| \t     |              |
| \b     |              |
| \r     |              |
| \xnn   | 十六进制     |
| \unnnn | unicode 字符 |

2. 字符串是不可变的。如果要更改，只能先删除，再重新赋值。这个部分已经浏览器默认做了。

3. 转换为字符串

`toString()` 任何数据类型除了 null 和 underfined，都有这个**方法**, 对于数值对象，还可以传递一个基数，返回相应进制的结果。

`String()` 加强版的 `toString()`, 正确返回 null 和 underfined。

####  Object 类型
对象就是一组数据和功能的集合。

每个对象都有以下属性和方法：

| 值                       | 含义                                         | 备注 |
|--------------------------|----------------------------------------------|------|
| `constructor`            | 构造函数                                     |      |
| `hasOwnProperty(string)` | 检查属性是否存在                             |      |
| `isPrototypeof(object)`  | 检查传入的对象是不是传入对象的原型           | *    |
| `propertyEnumberable()`  | 检查属性是不是一个迭代器，可以用 for-in 语句 |      |
| `toLocalString()`        |                                              |      |
| `toString()`             | 当对象转为字符串时调用的函数                 |      |
| `valueOf()`              | 返回对象的字符串，数值或布尔值表述           |      |

### 操作符
| 操作符         | 类型                 | 备注                                                           |
|----------------|----------------------|----------------------------------------------------------------|
| 前置后置操作符 | `++a, --a`           |                                                                |
|                | `a++`,`a--`          | 也适用于其他对象，会先转为 number 类型                         |
| 位操作符       |                      | 位操作符计算要先把64位转为32位，然后计算完成后再转回64位       |
|                | `~` not，非          | 操作数的负值减一                                               |
|                | `&` AND, 按位与      |                                                                |
|                | `\|` OR, 按位或      |                                                                |
|                | `^` XOR, 按位异或    |                                                                |
|                | `>>, <<`, 左移，右移 |                                                                |
|                | `>>>` 无符号右移     |                                                                |
| 布尔操作符     |                      | 别的数据类型会预先进行转型操作                                 |
|                | `!` 非               |                                                                |
|                | `&&` 与              | 短路操作符                                                     |
|                | `\|\|` 或            | 短路操作符                                                     |
| 算术操作符     | `*`                  | infinity*0=NaN,                                                |
|                | `/`                  | infinity/infinity=NaN, x/infinity=0                     |
|                | `%`                  | x%infinity=x, Infinity%Infinity=NaN
|                | `+`                  | 优先字符串操作, infinity+-infinity=NaN                         |
|                | `-`                  | -Infinity--Infinity=NaN                                        |
| 关系操作符     |                      |                                                                |
|                | `<` `>` `<=` `>=`    | 优先数值比较。字符串是比较单个的字符编码值，有一个大就返回结果 |
| 相等操作符     |                      |                                                                |
|                | `==`, `!=`           | 先转换再比较，null==underfined                                 |
|                | `===`,`!==`          | 不转换, null!==underfined                                      |
| 三元操作符     |                      |                                                                |
| 赋值操作符     |                      |                                                                |
| 逗号操作符     |                      | `var number=(1, 2, 3, 4, 5)`                                    |

### 语句
- if 语句
- do-while 语句
- while 语句
- for 语句
- for-in 语句

	精准的迭代语句,,遇到 null 和 underfined 会跳出循环。
	
	- [ ] 和 for of 的区别，哪个是适用迭代器的呢
- label 标签语句，配合 break 和 continue 来适用
- break 和 continue 语句
- with 语句，不建议适用，知道什么意思。
- switch 语句，可以用表达式，适用于多个 else 的情况。

### 函数
#### 定义一个函数
#### 理解函数的参数
ECMAScript 不介意传递进来多少个参数，也不在乎传递进来的参数的类型。所以，不能实现别的语言的**重载** 的效果。

本质上，是以一个类似数组的形式来接受这些参数。称为 `arguments` , 这个可以使用方括号语法来索引，可以使用长度属性。

这个数组和定义的参数名字的对应值是完全同步的，这意味着修改一个，另一个也同时变。但是二者不是一个相同的内存空间。

可以根据判断 arguments 的传递的参数的数目来实现弱小版的重载。

另外，ECMAScript 的所有参数传递的都是值，不是通过引用内存来传递参数。


## 变量、作用域和内存问题

### 基本类型和引用类型的值
ECMAScript 包括两种不同数据类型的值：基本类型值和引用类型值。

基本类型值指的就是简单的数据段。像 underfined, null, boolean, number , string 这5种基本数据类型都是基本类型值。

引用类型值就是保存在内存中的对象，变量名作为一个指针指向这个内存中的对象。object 就是引用类型的值。

### 复制变量值
对于基本类型值，复制操作会重新创建一个全新的，毫无联系的新变量。

```javascript
var num1=5
var num2=num1
```

num1 和 num2 中的储存的值是完全相等的都是5，但这两个变量是完全独立的，可以执行任何操作并且相互不影响。

对于引用类型值，复制操作会创建一个新的指针给变量，两个指针指向同一个内存地址。任意一个的改变都会引起另外的一个的变换。

### 函数传递参数
总的原则：**函数传参数都是传递值，不是传递引用的**。

对于基本类型值，传递到函数里面的时候，就创建一个新的局部变量，放在 arguments 当中。二者相互不影响。等同于在函数体中复制了一个新的局部变量；基本类型值保存在栈内存中。

对于引用类型值，把变量传递到函数中。这个变量在函数中指向的内存和在外面指向的内存是一样的。因此，在函数中更改这个对象的属性，函数外面做同步更改。引用类型值是对象，保存在堆内存中。

但这样并不意味着函数传递是按照引用传递的。

```javascript
function setName(obj){
	obj.name="Tom";
	obj = new Object();
	obg.name="Sam";
}

var person=new Object();
setName(person);
console.log(person.name); //Tom
```

像上面这段代码，如果是按照引用传递，那么函数中创建新对象的操作就会覆盖掉原来的内存，并且更改名字。但实际上，函数中重新修改变量的指向并没有影响原来的指向，原有的引用没有更改。实际上，重写 obj 时，是重新创建了一个新的局部对象。

所以，可以在函数中动态的修改对象的属性和方法，但无法更改这个变量指向的对象内存。

### 检测值类型
对于基本类型值，可以使用 typeof 来检测；

对于引用类型值，使用 `instanceof` 来检测。它是基于原型链的。

- [ ] 这个地方做补充

### 变量的作用域问题
#### 作用域链的概念

首先是一些概念：

1. **执行环境** , 定义了变量或函数有权访问的其它数据，决定了它们的各自的行为。可以理解为自己只有这么一点地方，只能用我自己的东西。这里的东西就叫做 **变量对象** .

2. **变量对象** , 环境中的变量和函数都保存在这个对象中，是这个对象的函数和方法。全局的变量对象是 windows 对象（在浏览器中）。

每个函数都是有自己的执行环境，相应的也有自己的变量对象。

当执行流到一个函数时，函数的执行环境就被推入一个环境栈当中，执行完了就把它弹出来。露出之前的执行环境。

当代码在一个环境中运行时，就会创建一个变量对象的**作用域链**。这个作用域链指定了执行环境的变量对象的访问次序。

举一个例子：

```javascript
function A(){
	var a=1;
	function B(){
		var b=1
	}
}
var c=1;
```

在这个代码当中呢，函数 B 中，形成了一个执行环境。

按照执行流的顺序，这里就有三个执行环境嵌套。最小的是函数 B 的执行环境，然后它被函数 A 的执行环境包围，然后最外面包围这两个的是全局的执行环境。

作用域链是什么呢，就如果 B 中的一个变量，会首先寻找在 B 的变量对象中的变量，然后如果没有，就继续向外搜索。如果找到了，停止搜索，确定这个变量。那么找完 B 的变量对象，就去找 A 的变量对象，最后找全局的变量对象。如果在全局变量对象中还没找到，那么就报错。

外面的执行环境可以使用对象的方法来进行访问。比如说函数和全局中都定义了一个变量 color，这两个是相互独立的，在函数中你只能访问到最近的变量对象中的 color，就是函数定义的这个。你可以使用 windows.color 来访问全局的这个同名变量。

#### 延长作用链 
可以通过两种办法来延长作用链，就是添加其他的变量对象。

- try-catch 语句的 catch 块；
	
	- [ ] 补充完善
	
- with 语句

```javascript
var qs=1;
with(location){
	var url=herf+qs;
}
```

这样，第一个变量对象就是 with 接受的对象，它的所有的方法和属性都可以作为变量被识别。第二个就是全局变量对象了。

就是 with 会在作用域链的 **最前面** 引入一个变量对象。 

#### Js 不存在块级作用域
牢记：只有 函数 可以形成自己的执行环境，拥有自己的变量对象。其他的代码块，什么 if，for这些都是没有，它们里面的变量都是属于最接近的执行环境的。

这个和 C 语言还是有很大差别，这里的块级作用域就是指的执行环境。

### 垃圾收集机制
JavaScript 具有**自动垃圾收集机制**, 无用的内存会自动回收。

回收的原理：**找出那些不在使用的变量，释放掉其占用的内存。垃圾收集器会按照固定的时间间隔来做这件事，代码也可以指定时间。** 

#### 如何识别“不再使用”
- 标记清除

	这是目前最常用的垃圾收集方式。

	局部变量不用讲，执行环境弹出后，会自动识别这部分局部变量没用了。

	标记清除的工作原理是：首先运行时会给所有的存储在内存中的变量都加上标记，标记可以通过翻转某一特殊的位或者用列表来实现。然后，它会去除掉当前执行环境以及被环境引用的变量的标记。在此之后的仍存在标记的变量将被清除。等到时间到了垃圾回收执行的时间，这些变量就没了。

- 引用计数

	工作原理是跟踪记录每个变量的使用次数。声明并将一个引用类型值赋值给变量时，次数记作1.如果这个同一个对象赋给另外一个变量时，次数加1. 如果，原来指向这个对象的变量现在指向另外一个对象，就减去1. 当这个引用次数变为0时，就等着被清除了。

	缺点是存在循环引用，就是一个对象的属性等于另外一个对象，这个闭环就永远不是 0 了。

小故事：

之前说垃圾回收器是按照时间周期执行的，但这个周期怎么确定呢？IE的垃圾收集是按照内存分配量执行的，比如最多多少个变量啊，对象啊。当达到这个数字的时候，垃圾收集就开始了。但是当一个脚本很大的时候，这个脚本执行期间，变量就会满足这个调剂，垃圾回收就会一直执行。浪费性能，并且还没什么用。

之后，它们采用了 **动态修正** 的想法, 就是看回收的内存多少，如果回收的多了，就把这个上限提高，如果回收的少了，就设为默认初始的值。

这个思想很值得学习。

#### 个人怎么管理内存

确保占用最少的内存可以让页面获得更好的性能。最好的办法是**只保存必要的数据**。

解除引用，创建使用完一个全局变量或者全局对象之后，确保之后不用了，就手工把它解除掉。

```javascript
objectName=null
```

这样的解除并不是马上回收这部分占用的内存，而是让这个值脱离执行环境，以便垃圾回收下次执行时将其回收。

## 引用类型
对象叫做引用类型的值，是引用类型的一个实例，引用类型是一种数据结构，用于将数据和功能组织在一起。常被称作是 类。

### Object 类型
#### 创建一个对象
大多是引用类型的值都是对象，是 object 的实例。

创建一个对象的方法有：

1. 使用 new + 构造函数；

	```javascript
	var person=new Object()
	```

2. 使用**对象字面量**

	```javascript
	var person={
		"name": "Tom"，
		"age": 29
	}
	```
	
	同样，构造函数仍然是 Object。 最后面不能有逗号， 属性和值用冒号分隔。

当需要向函数中大量传入参数时，可以使用对象来传递。

#### 对象的属性的访问
访问可以通过：

1. 点 表示法；
2. 类字典的表示法。

	使用这个可以用变量来代替键，可以用在分类赋值给属性的情况下。

	```javascript
	var propertyName='name'；
	console.log(person[propertyName]);
	```

	键里面有空格，或者使用的是关键字和保留字，都可以用这个来避免错误。但一般建议还是用点表示法，严格遵守标识符的命名规则。

### Array 类型
ECMAScript 的数组是动态可调整的，并且对每个项的类型都没有限制。可以直接通过控制数组长度，或者给赋值来改变数组。

#### 创建一个数组
1. new + 构造函数：
	
	```javascript
	var color=new Array();
	var color=new Array(23); //指定数组长度
	var color=new Array('Blue','Yellow')； //指定项创建数组
	```

	new 也可以省略掉，创建一定长度的应该很少用到。

2. 数组字面量创建

	```javascript
	var color=[];
	var color=['blue','yellow']
	```

#### 检测数组类型
使用 instanceof 会有问题，使用 `Array.isArray(array)` 来检测。

- [ ] 为什么 instanceof 会有问题。

#### 转换方法
每个对象都有 toString, toLocalString, 和 valueOf 方法。

对于数组，如果不加定义的话，toString() 返回数组元素用逗号分隔，然后拼接成一个的字符串。

valueOf() 返回一个数组，值的话和原数组一样。

- [ ] 需要做进一步的核实

可以自定义这些方法：

```javascript
var person={
toLocalString: function(){
		return 0;
 }
}
```

#### 数组的一些方法
1. **组合 `join()`**
	
	```javascript
	var color=['blue', "red", 'yellow'];
	var colorNew=color.join('-');

	console.log(color, colorNew);
	//[ 'blue', 'red', 'yellow' ] blue-red-yellow
	```

	| 参数   | 返回值         | 是否改变原数组 | 备注                                        |
	|--------|----------------|----------------|---------------------------------------------|
	| 分隔符 | 拼接后的字符串 | 不改变         | null， underfined会认为是空，出现两个分隔符 |

2. **开头，末尾增加删除元素**

	- 栈方法 `push()`, `pop()`
	- 队列方法，`shift()`, `unshift()`
	
	🧨

	| 方法    | 作用     | 参数         | 返回值           | 备注 |
	|---------|----------|--------------|------------------|------|
	| push    | 末尾添加 | 多个数组元素 | 修改后的数组长度 |      |
	| pop     | 末尾删除 | 无           | 删除的项         |      |
	| unshift | 开头添加 | 多个数组元素 | 修改后的长度     |      |
	| shift   | 开头删除 | 无           | 删除的项         |      |

	四种方法都是直接改变数组。

	也可以传递进去数组，但是只是作为一项放在相应的位置。

3. **排序 `reverse()` `sort()`**

	reverse 和 sort 方法都改变原数组。

	sort() 默认按照升序排列，默认比较方法是每个数组项的 toString() 转型，然后比较字符串。 所以如果直接对数值类型排序会出现错误。⚠

	sort() 还可以接受一个比较函数作为参数，指定哪个值应该大。比较函数会从 sort 接受两个值，对这两个值操作，如果返回0，意味着这两个项相等。如果是 -1， 第二个就比第一个大，不改变顺序。 如果是 1， 意味这第一个大，则交换顺序，向后排。

	```javascript
	array.sort((value1, value2)=>{
		return value2 - value1；
			})
	```

	这是一个降序排列数值类型的方法。

4. **拼接和替换， `concat()` `slice()` `splice()`**
	
	- `concat()` ---- 升级版的 `push()`，拼接数组的

		会先创建一个不同内存地址的副本，然后将接受到的参数添加到副本的末尾。	

		| 参数     | 返回值                     | 备注             |
		|----------|----------------------------|------------------|
		| 没有参数 | 复制一个新数组             | 深复制，二者独立 |
		| 数组     | 每个项都拿出来，添加到末尾 |                  |
		| 元素     | push                       |                  |

		对原数组没有改变。

	- `slice()` 切片
		
		基于当前数组中的一个或者多个项创建一个新数组。

		不会影响原数组。

		两个参数，起始索引和终止索引，切片结果包括起始项不包括终止项。第二个参数可选，没有则代表切到末尾。
		
		返回一个被切的元素组成的数组。

		如果是负数，就代表从后开始切，用长度加上这个负数就是相应的正数结果了。

	- `splice()`
		
		一个超级强大的方法。

		| 参数                     | 效果   | 返回值             | 备注 |
		|--------------------------|--------|--------------------|------|
		| 两个参数(起始坐标，项数) | 删除项 | 删除的项组成的数组 |      |
		| 三个(~，0，插入的项)     | 插入   | 空数组             |      |
		| 三个(~,~,项)             | 替换   | 删除的项组成的数组 |      |

		总之还是删，三种方法都是一样的操作模式。删除几项，然后再在相应的位置做改变。都是一个操作，没什么严格的并列关系。

		最终都是返回删除元素组成的数组。

		这是一种破坏原数组的方法。

5. **获得索引 `indexOf()` `lastIndexOf()`**

	前者从开头开始搜索，后者从末尾开始搜索。

	接受两个参数，查找的项和查找起点的索引值。

	使用全等操作符，意味着查找对象要使用完全一样的内存地址来查找，就是直接用变量名来查找，不能新建一个。

	查不到，就返回 -1，正常下返回第一个查到的符合条件的项的索引。

6. **迭代方法**

	每个函数都接受两个参数，要运行的函数和运行该函数的作用域对象----影响 this 的值。

	- [ ] 补充
	
	传入的函数会接受三个值，数组的项，数组的项的索引，数组对象本身。

	| 方法        | 返回值                               | 备注 |
	|-------------|--------------------------------------|------|
	| `every()`   | 所有的函数执行结果为 true, 返回 true |      |
	| `some()`    | 有一个执行结果为 true， 返回 true    |      |
	| `filter()`  | 返回一个数组，执行结果为true对应的项 |      |
	| `forEach()` | 不返回                               |      |
	| `map()`     | 返回函数执行结果组成的数组           |      |

7. **归并方法， 累计的思想**
	
	迭代的升级版。

	两个参数，执行函数和（可选的）作为归并基础的初始值。

	执行函数接受四个值，前一个值，后一个值，项的索引，数组对象。第一次迭代从第二项开始，函数执行的返回结果会作为下一次迭代的前一个值。

	```javascript
	var color=[1,2,3,4,5];
	var base=10;

	var sum=color.reduce((pre, cur)=>{
		return pre+cur;
	}, base)
	console.log(sum); //25
	```

	最后所有迭代完了，就返回最后的这个值。
	
	`reduce()` 和 `reduceRight()` 就是方向不一样。 
	

🎈最后，做个总结，**改变原数组的方法有：** 

`push(), pop(), shift(), unshift()`, `slice(), splice()`, `sort(), reverse() `

### Date 类型
Date 类型使用 UTC（coordinated universal Time）1970年 1 月 1 日 午时零点开始的毫秒数来保存日期，所以能够精确保存这个时间点之前和之后的 28 万年。

#### 创建 Date 类型
使用 Date 构造函数来创建：

```javascript
var now=new Date()
```

- 不传参数，自动获取当前的时间；
- 可以指定时间，传递一个 UTC 经过的毫秒数；
- 可以用 Date.parse() 来返回一个 UTC 毫秒数，用来指定一个时间。这个函数接受一个表示日期的字符串，格式不确定。 也可以在构造函数中直接传字符串，默认会调用这个函数；
- 可以用 Date.UTC() 来返回一个 UTC 毫秒数。参数是（年份，月份（0-11）， 月份天，。。。）， 也可直接在构造函数中传地参数。

	这个函数是基于本地时间来创建的，不是格林威治时间。

#### 静态方法
静态方法就是只能由构造函数来调用，实例不能调用。

有一个 `Date.time()` 返回当前毫秒数。

#### 继承来的方法
`toLocalString()` 返回带有上下午的时间；

`toString()` 返回带有时区信息的时间；

`valueOf()` 返回毫秒数，可以直接比较 date 对象，就会默认调用这个方法

```javascript
var date1=new Date(2001, 0, 1):
var date2=new Date(2002, 0, 1):
console.log(date1>date2)//true
```

#### 日期的格式化方法
`toDateString()` 特定的格式显示；
`toTimeString()`
`toLocalDateString()` 
`toLocalTimeString()` 
`toUTCString()` 

#### 获得设置日期的组件方法
可以获得 

| 方法            | 作用             |
|-----------------|------------------|
| `getTime()`     | 返回毫秒数       |
| `getFullYear()` | 返回四位数的年份 |
| `getMonth()`    | 返回月份（0-11） |
| `getDate()`     | 返回月份的天数   |
| `getDay()`      | 返回星期的天数（0-6）                 |

类似的还有分钟啊，秒，毫秒啊，等等。每个类型都有 `getUTCTime()`, `setTime()`, `setUTCTime()` 其它三个方法。

最后还有一个 `getTimezoneOffset()`，返回一个本地时间和格林威治时间的差的分钟数。

### RegExp 类型 
正则表达式，类似 perl 的语法。 分为 模式（pattern） 和 标志（flags） 两部分。

`var exp=/pattern/ flags(g, i, m)`

#### 创建正则表达式
- 字面量创建
	
	```javascript
	var pattern=/.ac/g;
	```

- 构造函数创建

	```javascript
	var pattern=new RegExp("\\.ac",'g');
	```

	使用这个时候，注意双重转义，正则转一次，字符串再转一次。

字面量创建的效率更高一点。

#### 属性
属性分为两部分：**实例属性** 和 **静态属性**。

实例属性：

| 属性        | 作用                       | 备注 |
|-------------|----------------------------|------|
| global      | 判断是不是设置 g 标志      |      |
| ignoreCase  |                            |      |
| lastIndexOf |                            |      |
| multiline   |                            |      |
| source      | 正则表达式，字面量形式表达 |      |

前四个方法都没用，第五个用的也不多。

静态属性：

只能构造函数用，不能实例用。作用于执行环境中所有的正则表达式，依据最后一次执行的正则表达式来变化。

| 属性                | 作用             | 说明 |
|---------------------|------------------|------|
| input               | 匹配的字符串     |      |
| lastMatch           |                  |      |
| lastParen           | 最近的匹配捕获组 |      |
| leftContext, right~ | 匹配完剩下的     |      |
| multiline           |                  |      |

这些属性名还有一系列的短属性名，使用的时候也挺麻烦的，要按照关联数组那么用。

`$1, -, 9` 分别储存则第一到第九个匹配的捕获组。

#### 实例方法

- `exec()` 捕获，返回捕获结果的
	
	返回包含第一个匹配项的信息的一个关联数组，没有匹配到的话返回 null.

	```javascript
	re= /.at/g;
	console.log(re.exec("cat, aat, lat"))
	//[ 'cat', index: 0, input: 'cat, aat, lat', groups: undefined ]
	console.log(re.exec("cat, aat, lat"))
	//[ 'aat', index: 5, input: 'cat, aat, lat', groups: undefined ]
	```

	[0]返回第一个匹配结果，[1] 之后的就返回 匹配组的内容了。其他的信息就需要用关联数组了。

	如果想匹配多个内容，就需要不断执行这个命令，会记住上次匹配的 lastIndexOf 。记得要在正则字面量中表定全局标志。

#### 继承方法
`toLocalString()`, `toString()` 都返回表达式的字面量；

`valueOf()` 返回表达式本身这个对象。


### function 类型
function 本质是一个对象，每个函数都是 Function 的实例，都具有属性和方法。

因此，**因此，函数名实际上就是一个指向函数对象的指针，和一般的变量没有区别**。

由于函数名只是一个指针，所以函数没有重载。因为如果定义了重复使用一个变量来指向两个不同的函数对象时，只会保存后面的。

函数这种变量的特征，我们就可以使用函数名（没有后面的括号，如果带括号，就代表执行函数。）来指代函数体。 作为参数传递给另外的函数，或者赋值给另外一个变量。

#### 创建函数对象
1. 使用函数声明语法定义

	```javascript
	function sum(num1, num2){
		return 0;
	}
	```

2. 使用函数表达式

	```javascript
	var sum= function(num1, num2){
		return num1+num2;
	}；
	```

	和定义其他变量时一模一样。

3. 使用构造函数

	```javascript
	var sum=new Function("num1", "num2", "return num1+num2");
	```

函数声明和函数表达式有所区别，主要在于声明提升上。使用函数声明，解释引擎会先解读 function , 然后到执行到代码处，才会执行相关语法。这样，即使在函数创建之前也可以正确使用函数，不会报错。 函数表达式则不能使函数提升。

#### 函数对象的属性
函数有两个特殊的属性，他们都是对象。就是 `arguments`对象和 `this` 对象。

- arguments 对象
	类数组对象，之前介绍过。

	它有一个属性， 叫做 `callee`，指向拥有这个 arguments 对象的函数。

	这个属性在递归函数中有作用，可以指代函数自身。

	```javascript
	function factorial(num){
		if(num<=1){
			return 1;
		}else{
			return num * arguments.callee(num-1);
		}
	}
	```

	这个 `arguments.callee` 这里就指向 `factorial` 这个函数体，二者指向同一个函数对象。

	这个做法可以有效的防止递归语法对于函数名字的依赖，同步函数名和执行体中的同步变化。

- this 对象

	这个对象指向函数的执行环境，代表执行环境中的变量对象。

	如果是在全局环境中执行函数，就相当于 windows.func(), 那么这个this 就代表函数变量对象和win对象。 如果是 o.func() 那么这个this就代表 函数变量对象， o变量对象和win变量对象。

与 `callee` 对应，函数有一个 `caller` 属性

- `caller` 属性

	这个属性保存着调用当前函数的函数的引用，会返回函数的变量。就是谁在使用当前函数。

	`arguments.callee.caller`

	**严格模式下不能用，包括 callee 属性**。

还有其他的一般属性

- length

	返回函数希望接受的命名参数的个数，只是括号里面的参数的个数。

- prototype

	原型属性，下面定义了所有实例的方法，像 toString(), valueOf()等等。

#### 函数对象方法
两个特殊的方法，`apply()`, `call()`。这两个函数都是用来指定 this 对象的值，用来指向不同的变量对象，为函数添加更多的变量对象。

- apply() 方法

	两个参数，第一个是变量对象，第二个是其中的参数数组。

	```javascript
	
	```

	<++>
