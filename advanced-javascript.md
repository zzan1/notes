
<!-- TOC GitLab -->

+ [JavaScript 高级程序设计的笔记](#javascript-高级程序设计的笔记)
	* [JavaScript 历史](#javascript-历史)
	* [在 HTML 中使用 javascript](#在-html-中使用-javascript)
		- [`<script>` 属性介绍](#script-属性介绍)
		- [使用 `<script>`](#使用-script)
			+ [嵌入式](#嵌入式)
			+ [外部链接 javascript](#外部链接-javascript)
			+ [浏览器的解释顺序](#浏览器的解释顺序)
			+ [文档类型 `DOCTYPE`](#文档类型-doctype)
			+ [使用 `<noscript>` 标签](#使用-noscript-标签)
	* [基本概念](#基本概念)
		- [注意事项](#注意事项)
		- [数据类型](#数据类型)
			+ [检测数据类型](#检测数据类型)
			+ [underfined 类型](#underfined-类型)
			+ [null 类型](#null-类型)
			+ [Boolean 类型](#boolean-类型)
			+ [Number 类型](#number-类型)
			+ [string 类型](#string-类型)
			+ [Object 类型](#object-类型)
		- [操作符](#操作符)
		- [语句](#语句)
		- [函数](#函数)
			+ [定义一个函数](#定义一个函数)
			+ [理解函数的参数](#理解函数的参数)
	* [变量、作用域和内存问题](#变量作用域和内存问题)
		- [基本类型和引用类型的值](#基本类型和引用类型的值)
		- [复制变量值](#复制变量值)
		- [函数传递参数](#函数传递参数)
		- [检测值类型](#检测值类型)
		- [变量的作用域问题](#变量的作用域问题)
			+ [作用域链的概念](#作用域链的概念)
			+ [延长作用链](#延长作用链)
			+ [Js 不存在块级作用域](#js-不存在块级作用域)
		- [垃圾收集机制](#垃圾收集机制)
			+ [如何识别“不再使用”](#如何识别不再使用)
			+ [个人怎么管理内存](#个人怎么管理内存)

<!-- /TOC -->


# JavaScript 高级程序设计的笔记

## JavaScript 历史

pass

## 在 HTML 中使用 javascript

### `<script>` 属性介绍

- `async`，异步脚本，表示立即下载脚本，但不应妨碍页面中的其他操作；
- `charset`, 很少用，用于指定代码使用的字符集；
- `defer`, 延迟脚本，表示脚本可以延迟到文档完全被解析和显示之后再执行；
- `language`, 已废弃；
- `type`, 指定 MIME 类型，默认使用的值是 `application/x-javascript`, 设置这个值可能导致脚本被忽略；
- `src`, 指定源文件地址。

### 使用 `<script>`

使用 `script` 标签主要有两种方法：**嵌入式** 和 **外部式**。

#### 嵌入式

直接在标签内部加入代码。

注意代码中不能出现 `</script>` 字符串，浏览器加载时会认为这是代码的结束标志。可以使用 `<\/script>` 来进行转义操作，避免错误。

HTML5 中规定，嵌入式的 JavaScript 不能使用 defer 和 async 属性。

#### 外部链接 javascript

使用 src 属性指定文件地址，不能在标签内部插入任何代码。和嵌入式代码是水火不相容的，只能选择使用一个。

- 使用 延迟脚本
```javascript
<script src="index.js" defer="defer"></script>	
```

- 使用 异步脚本
```javascript
<script src="index.js" async></script>	
```

使用外部脚本的好处：
- 便于维护；
- 缓存，多个页面使用同一个 js 可以只下载一次；
- 使用于未来，方便从 HTML 升级到 Xhtml。

#### 浏览器的解释顺序

- 首先，执行 js 代码时，网页的内容加载暂停；
- 大原则是：**顺序执行**，按照标签位置的顺序执行；
- 延迟执行脚本：脚本延迟到整个页面都解析完毕之后再运行。

	当存在多个延迟脚本时，HTML5 规定按顺序执行，并且先于`DOMContentLoaded` 事件执行。但实际情况则不是按顺序执行，并且也不会先于事件触发。因此建议只包含一个延迟脚本。

- 异步执行脚本：告诉浏览器立即执行脚本，并且不妨碍页面中其他操作。

  异步脚本一定会在页面的 `load` 事件前执行，但不一定会在 `DOMContentLoaded` 之前执行。多个异步脚本不一定按照先后顺序执行。


#### 文档类型 `DOCTYPE`
文档类型主要分为两种：混杂式和严格式。

混杂式会让 IE 的行为与 IE5 相同，标准模式会让 IE 更接近标准行为。主要影响 CSS 的呈现行为。

HTML5 使用 `<!DOCTYPE html>` 默认是标准模式。

#### 使用 `<noscript>` 标签
用于处理浏览器默认不支持 js 脚本的行为。

当浏览器不支持 js 或者禁用 js 时，会显示整个标签内部的 HTML 内容。

## 基本概念
### 注意事项
- 区分大小写；
- 标识符，就是函数名的格式要求；
- 严格模式，`use strict`;
- 关键字和保留字。使用关键字会引起 `Identifier Expected` 错误；
- 变量，全局变量和局部变量。

### 数据类型
有六种基本的数据类型：

`underfined, null, Boolean, Number, String, Object`

#### 检测数据类型
`typeof `操作符，检测结果如下：

| 类型         | 结果         |
|--------------|--------------|
| underfined   | 'underfined' |
| Boolean      | 'boolean'    |
| String       | 'string'     |
| Number       | 'number'     |
| Object, null | 'object'     |
| function     | 'function'   |

单独的列出了函数的检测结果。六种基本数据类型当中的 null 合并到 object 中了，因为 null 本身就是一个空对象指针。

#### underfined 类型
注意变量未初始化的结果是 underfined 类型。

使用 typeof 检测未声明的变量时仍然会显示 underfined 类型，注意区分。

#### null 类型
一定注意，null 是一个**空对象指针**。

一般定义一个变量准备保存对象时，最好首先将其初始化为 null。这样，可以直接检测 null 值就可以判断这个变量是否已经保存了一个对象的引用。

#### Boolean 类型
区分大小写，只有小写才表示正常的真，假值。

转型函数 `Boolean()`:

| 数据类型   | 真值       | 假值   |
|------------|------------|--------|
| string     | 非空字符串 | 空     |
| number     | 非零       | 0和NaN |
| object     | 任何对象   | null   |
| underfined | 没有       | 本身   |

#### Number 类型
ECMAScript 使用 IEEE754（二进制浮点数计算标准）保存所有的数字类型为浮点数，采用64位双精度的格式。其中，0-51位表示数字，52-62表示指数，代表小数点的位置，63位是正负号的位置。因此，小数的最高精度是17位。

- [ ] 17位有效数字的详细原因。

[数字在JavaScript中是如何编译的](https://segmentfault.com/a/1190000014867071) 

著名的问题：
> 0.1+0.2!=0.3 

这是因为 0.1 和 0.2 都不能完全的化简为二进制，然后相加后也没办法化简。在最高精度内存在数字，因此，JS 不认为这个结果和 0.3 相等。这是采用 IEEE754 标准的所有语言的问题。

```javascript
0.1+0.2
0.30000000000000004
```

十进制和二进制小数的转换，负数的转换。

存储单位：64位(bit) = 8 字节(byte), 1 KB=1024 byte. 说的汉字属于宽字符，双字节的，就是这个意思。

- 浮点数，浮点数的占用内存是整数值的两倍，所以 JS 会自动的转为整数；
- 数值范围，存在一个 `Infinity, -Infinity` 范围，可以使用 `Number.MIN_VALUE` 属性查看，可以使用 `isFinte()` 来判断一个数是否在有效范围内，是返回真。
- NaN，not a number, 表示本该返回数值的操作结果并未返回数值的情况。任何数除以 0 就会出现这种结果。任何设计 Nan 的计算结果都是 NaN, NaN 与任何值都不相等，包括本身。

	可以使用 `isNaN()` 函数来判断是不是正确数值。可以传入字符串（思考一下结果），对象（思考一下过程）。

---
*一个比较重要的问题: 数值转换问题* 

| `Number()`                     | `parseInt()`                           | `parseFloat()`   |
|--------------------------------|----------------------------------------|------------------|
| 多种类型                       | 仅限于字符串                           | 仅限于字符串     |
| 识别正负号，小数点，和空字符串 | 只识别以数字开头的字符串，不支持小数点 | 改进，支持小数点 |

`number()` 函数在多种类型时的处理：

| 数值类型                          | 结果           |
|-----------------------------------|----------------|
| boolean                           | 1,0            |
| number                            | 简单的传入传出 |
| null                              | 0              |
| underfined                        | NaN            |
| string                            |                |
| -- 正负号，小数点，进制，空字符串 | 正常识别       |
| -- 有不认识的，`12bule`           | NaN            |
| Object                            | 正常对象的处理 |

`parseInt()` 函数的特点：

**工作机制**：从字符串开头开始，忽略开头的空格，如果开头第一个非空字符不是数字或者正负号，直接返回 NaN。如果找到第一个数字，就会继续向后找，直至不是数字为止。

一个例子，`123 1blue` 返回 123，不会去掉空格，不会识别字母，不是数字直接退出。

不识别小数点。

可以提供第二个参数, 作为进制的指示，可以传入一个 Number 数值，表明返回结果的进制。

`parseFloat()` 函数：

改进版的 `parseInt()`, 识别小数了。只识别第一个小数点。

不支持基数(就是第二个参数)。另外，输入也只支持十进制，十六进制为返回0。

#### string 类型
1. 字符字面量，就是一些特殊的字符。

| 字面量 | 含义         |
|--------|--------------|
| \n     |              |
| \t     |              |
| \b     |              |
| \r     |              |
| \xnn   | 十六进制     |
| \unnnn | unicode 字符 |

2. 字符串是不可变的。如果要更改，只能先删除，再重新赋值。这个部分已经浏览器默认做了。

3. 转换为字符串

`toString()` 任何数据类型除了 null 和 underfined，都有这个**方法**, 对于数值对象，还可以传递一个基数，返回相应进制的结果。

`String()` 加强版的 `toString()`, 正确返回 null 和 underfined。

####  Object 类型
对象就是一组数据和功能的集合。

每个对象都有以下属性和方法：

| 值                       | 含义                                         | 备注 |
|--------------------------|----------------------------------------------|------|
| `constructor`            | 构造函数                                     |      |
| `hasOwnProperty(string)` | 检查属性是否存在                             |      |
| `isPrototypeof(object)`  | 检查传入的对象是不是传入对象的原型           | *    |
| `propertyEnumberable()`  | 检查属性是不是一个迭代器，可以用 for-in 语句 |      |
| `toLocalString()`        |                                              |      |
| `toString()`             | 当对象转为字符串时调用的函数                 |      |
| `valueOf()`              | 返回对象的字符串，数值或布尔值表述           |      |

### 操作符
| 操作符         | 类型                 | 备注                                                           |
|----------------|----------------------|----------------------------------------------------------------|
| 前置后置操作符 | `++a, --a`           |                                                                |
|                | `a++`,`a--`          | 也适用于其他对象，会先转为 number 类型                         |
| 位操作符       |                      | 位操作符计算要先把64位转为32位，然后计算完成后再转回64位       |
|                | `~` not，非          | 操作数的负值减一                                               |
|                | `&` AND, 按位与      |                                                                |
|                | `\|` OR, 按位或      |                                                                |
|                | `^` XOR, 按位异或    |                                                                |
|                | `>>, <<`, 左移，右移 |                                                                |
|                | `>>>` 无符号右移     |                                                                |
| 布尔操作符     |                      | 别的数据类型会预先进行转型操作                                 |
|                | `!` 非               |                                                                |
|                | `&&` 与              | 短路操作符                                                     |
|                | `\|\|` 或            | 短路操作符                                                     |
| 算术操作符     | `*`                  | infinity*0=NaN,                                                |
|                | `/`                  | infinity/infinity=NaN, x/infinity=infinity                     |
|                | `%`                  | x%infinity=x, Infinity%Infinity=NaN
|                | `+`                  | 优先字符串操作, infinity+-infinity=NaN                         |
|                | `-`                  | -Infinity--Infinity=NaN                                        |
| 关系操作符     |                      |                                                                |
|                | `<` `>` `<=` `>=`    | 优先数值比较。字符串是比较单个的字符编码值，有一个大就返回结果 |
| 相等操作符     |                      |                                                                |
|                | `==`, `!=`           | 先转换再比较，null==underfined                                 |
|                | `===`,`!==`          | 不转换, null!==underfined                                      |
| 三元操作符     |                      |                                                                |
| 赋值操作符     |                      |                                                                |
| 逗号操作符     |                      | `var number=(1, 2, 3, 4, 5)`                                    |

### 语句
- if 语句
- do-while 语句
- while 语句
- for 语句
- for-in 语句

	精准的迭代语句,,遇到 null 和 underfined 会跳出循环。
	
	- [ ] 和 for of 的区别，哪个是适用迭代器的呢
- label 标签语句，配合 break 和 continue 来适用
- break 和 continue 语句
- with 语句，不建议适用，知道什么意思。
- switch 语句，可以用表达式，适用于多个 else 的情况。

### 函数
#### 定义一个函数
#### 理解函数的参数
ECMAScript 不介意传递进来多少个参数，也不在乎传递进来的参数的类型。所以，不能实现别的语言的**重载** 的效果。

本质上，是以一个类似数组的形式来接受这些参数。称为 `arguments` , 这个可以使用方括号语法来索引，可以使用长度属性。

这个数组和定义的参数名字的对应值是完全同步的，这意味着修改一个，另一个也同时变。但是二者不是一个相同的内存空间。

可以根据判断 arguments 的传递的参数的数目来实现弱小版的重载。

另外，ECMAScript 的所有参数传递的都是值，不是通过引用内存来传递参数。


## 变量、作用域和内存问题

### 基本类型和引用类型的值
ECMAScript 包括两种不同数据类型的值：基本类型值和引用类型值。

基本类型值指的就是简单的数据段。像 underfined, null, boolean, number , string 这5种基本数据类型都是基本类型值。

引用类型值就是保存在内存中的对象，变量名作为一个指针指向这个内存中的对象。object 就是引用类型的值。

### 复制变量值
对于基本类型值，复制操作会重新创建一个全新的，毫无联系的新变量。

```javascript
var num1=5
var num2=num1
```

num1 和 num2 中的储存的值是完全相等的都是5，但这两个变量是完全独立的，可以执行任何操作并且相互不影响。

对于引用类型值，复制操作会创建一个新的指针给变量，两个指针指向同一个内存地址。任意一个的改变都会引起另外的一个的变换。

### 函数传递参数
总的原则：**函数传参数都是传递值，不是传递引用的**。

对于基本类型值，传递到函数里面的时候，就创建一个新的局部变量，放在 arguments 当中。二者相互不影响。等同于在函数体中复制了一个新的局部变量；基本类型值保存在栈内存中。

对于引用类型值，把变量传递到函数中。这个变量在函数中指向的内存和在外面指向的内存是一样的。因此，在函数中更改这个对象的属性，函数外面做同步更改。引用类型值是对象，保存在堆内存中。

但这样并不意味着函数传递是按照引用传递的。

```javascript
function setName(obj){
	obj.name="Tom";
	obj = new Object();
	obg.name="Sam";
}

var person=new Object();
setName(person);
console.log(person.name); //Tom
```

像上面这段代码，如果是按照引用传递，那么函数中创建新对象的操作就会覆盖掉原来的内存，并且更改名字。但实际上，函数中重新修改变量的指向并没有影响原来的指向，原有的引用没有更改。实际上，重写 obj 时，是重新创建了一个新的局部对象。

所以，可以在函数中动态的修改对象的属性和方法，但无法更改这个变量指向的对象内存。

### 检测值类型
对于基本类型值，可以使用 typeof 来检测；

对于引用类型值，使用 `instanceof` 来检测。它是基于原型链的。

- [ ] 这个地方做补充

### 变量的作用域问题
#### 作用域链的概念

首先是一些概念：

1. **执行环境** , 定义了变量或函数有权访问的其它数据，决定了它们的各自的行为。可以肩带理解为自己只有这么一点地方，只能用我自己的东西。这里的东西就叫做 **变量对象** .

2. **变量对象** , 环境中的变量和函数都保存在这个对象中，是这个对象的函数和方法。全局的变量对象是 windows 对象（在浏览器中）。

每个函数都是有自己的执行环境，相应的也有自己的变量对象。

当执行流到一个函数时，函数的执行环境就被推入一个环境栈当中，执行完了就把它弹出来。露出之前的执行环境。

当代码在一个环境中运行时，就会创建一个变量对象的**作用域链**。这个作用域链指定了执行环境的变量对象的访问次序。

举一个例子：

```javascript
function A(){
	var a=1;
	function B(){
		var b=1
	}
}
var c=1;
```

在这个代码当中呢，函数 B 中，形成了一个执行环境。

按照执行流的顺序，这里就有三个执行环境嵌套。最小的是函数 B 的执行环境，然后它被函数 A 的执行环境包围，然后最外面包围这两个的是全局的执行环境。

作用域链是什么呢，就如果 B 中的一个变量，会首先寻找在 B 的变量对象中的变量，然后如果没有，就继续向外搜索。如果找到了，停止搜索，确定这个变量。那么找完 B 的变量对象，就去找 A 的变量对象，最后找全局的变量对象。如果在全局变量对象中还没找到，那么就报错。

外面的执行环境可以使用对象的方法来进行访问。比如说函数和全局中都定义了一个变量 color，这两个是相互独立的，在函数中你只能访问到最近的变量对象中的 color，就是函数定义的这个。你可以使用 windows.color 来访问全局的这个同名变量。

#### 延长作用链 
可以通过两种办法来延长作用链，就是添加其他的变量对象。

- try-catch 语句的 catch 块；
	
	- [ ] 补充完善
	
- with 语句

```javascript
var qs=1;
with(location){
	var url=herf+qs;
}
```

这样，第一个变量对象就是 with 接受的对象，它的所有的方法和属性都可以作为变量被识别。第二个就是全局变量对象了。

就是 with 会在作用域链的 **最前面** 引入一个变量对象。 

#### Js 不存在块级作用域
牢记：只有 函数 可以形成自己的执行环境，拥有自己的变量对象。其他的代码块，什么 if，for这些都是没有，它们里面的变量都是属于最接近的执行环境的。

这个和 C 语言还是有很大差别，这里的块级作用域就是指的执行环境。

### 垃圾收集机制
JavaScript 具有**自动垃圾收集机制**, 无用的内存会自动回收。

回收的原理：**找出那些不在使用的变量，释放掉其占用的内存。垃圾收集器会按照固定的时间间隔来做这件事，代码也可以指定时间。** 

#### 如何识别“不再使用”
- 标记清除

	这是目前最常用的垃圾收集方式。

	局部变量不用讲，执行环境弹出后，会自动识别这部分局部变量没用了。

	标记清除的工作原理是：首先运行时会给所有的存储在内存中的变量都加上标记，标记可以通过翻转某一特殊的位或者用列表来实现。然后，它会去除掉当前执行环境以及被环境引用的变量的标记。在此之后的仍存在标记的变量将被清除。等到时间到了垃圾回收执行的时间，这些变量就没了。

- 引用计数

	工作原理是跟踪记录每个变量的使用次数。声明并将一个引用类型值赋值给变量时，次数记作1.如果这个同一个对象赋给另外一个变量时，次数加1. 如果，原来指向这个对象的变量现在指向另外一个对象，就减去1. 当这个引用次数变为0时，就等着被清除了。

	缺点是存在循环引用，就是一个对象的属性等于另外一个对象，这个闭环就永远不是 0 了。

小故事：

之前说垃圾回收器是按照时间周期执行的，但这个周期怎么确定呢？IE的垃圾收集是按照内存分配量执行的，比如最多多少个变量啊，对象啊。当达到这个数字的时候，垃圾收集就开始了。但是当一个脚本很大的时候，这个脚本执行期间，变量就会满足这个调剂，垃圾回收就会一直执行。浪费性能，并且还没什么用。

之后，它们采用了 **动态修正** 的想法, 就是看回收的内存多少，如果回收的多了，就把这个上限提高，如果回收的少了，就设为默认初始的值。

这个思想很值得学习。

#### 个人怎么管理内存

确保占用最少的内存可以让页面获得更好的性能。最好的办法是**只保存必要的数据**。

解除引用，创建使用完一个全局变量或者全局对象之后，确保之后不用了，就手工把它解除掉。

```javascript
objectName=null
```

这样的解除并不是马上回收这部分占用的内存，而是让这个值脱离执行环境，以便垃圾回收下次执行时将其回收。
