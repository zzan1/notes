
<!-- TOC GitLab -->

+ [JavaScript 高级程序设计的笔记](#javascript-高级程序设计的笔记)
	* [JavaScript 历史](#javascript-历史)
	* [在 HTML 中使用 javascript](#在-html-中使用-javascript)
		- [`<script>` 属性介绍](#script-属性介绍)
		- [使用 `<script>`](#使用-script)
			+ [嵌入式](#嵌入式)
			+ [外部链接 javascript](#外部链接-javascript)
			+ [浏览器的解释顺序](#浏览器的解释顺序)
			+ [文档类型 `DOCTYPE`](#文档类型-doctype)
			+ [使用 `<noscript>` 标签](#使用-noscript-标签)
	* [基本概念](#基本概念)
		- [注意事项](#注意事项)
		- [数据类型](#数据类型)
			+ [检测数据类型](#检测数据类型)
			+ [underfined 类型](#underfined-类型)
			+ [null 类型](#null-类型)
			+ [Boolean 类型](#boolean-类型)
			+ [Number 类型](#number-类型)
		- [string 类型](#string-类型)
		- [Object 类型](#object-类型)

<!-- /TOC -->


# JavaScript 高级程序设计的笔记

## JavaScript 历史

pass

## 在 HTML 中使用 javascript

### `<script>` 属性介绍

- `async`，异步脚本，表示立即下载脚本，但不应妨碍页面中的其他操作；
- `charset`, 很少用，用于指定代码使用的字符集；
- `defer`, 延迟脚本，表示脚本可以延迟到文档完全被解析和显示之后再执行；
- `language`, 已废弃；
- `type`, 指定 MIME 类型，默认使用的值是 `application/x-javascript`, 设置这个值可能导致脚本被忽略；
- `src`, 指定源文件地址。

### 使用 `<script>`

使用 `script` 标签主要有两种方法：**嵌入式** 和 **外部式**。

#### 嵌入式

直接在标签内部加入代码。

注意代码中不能出现 `</script>` 字符串，浏览器加载时会认为这是代码的结束标志。可以使用 `<\/script>` 来进行转义操作，避免错误。

HTML5 中规定，嵌入式的 JavaScript 不能使用 defer 和 async 属性。

#### 外部链接 javascript

使用 src 属性指定文件地址，不能在标签内部插入任何代码。和嵌入式代码是水火不相容的，只能选择使用一个。

- 使用 延迟脚本
```javascript
<script src="index.js" defer="defer"></script>	
```

- 使用 异步脚本
```javascript
<script src="index.js" async></script>	
```

使用外部脚本的好处：
- 便于维护；
- 缓存，多个页面使用同一个 js 可以只下载一次；
- 使用于未来，方便从 HTML 升级到 Xhtml。

#### 浏览器的解释顺序

- 首先，执行 js 代码时，网页的内容加载暂停；
- 大原则是：**顺序执行**，按照标签位置的顺序执行；
- 延迟执行脚本：脚本延迟到整个页面都解析完毕之后再运行。

	当存在多个延迟脚本时，HTML5 规定按顺序执行，并且先于`DOMContentLoaded` 事件执行。但实际情况则不是按顺序执行，并且也不会先于事件触发。因此建议只包含一个延迟脚本。

- 异步执行脚本：告诉浏览器立即执行脚本，并且不妨碍页面中其他操作。

  异步脚本一定会在页面的 `load` 事件前执行，但不一定会在 `DOMContentLoaded` 之前执行。多个异步脚本不一定按照先后顺序执行。


#### 文档类型 `DOCTYPE`
文档类型主要分为两种：混杂式和严格式。

混杂式会让 IE 的行为与 IE5 相同，标准模式会让 IE 更接近标准行为。主要影响 CSS 的呈现行为。

HTML5 使用 `<!DOCTYPE html>` 默认是标准模式。

#### 使用 `<noscript>` 标签
用于处理浏览器默认不支持 js 脚本的行为。

当浏览器不支持 js 或者禁用 js 时，会显示整个标签内部的 HTML 内容。

## 基本概念
### 注意事项
- 区分大小写；
- 标识符，就是函数名的格式要求；
- 严格模式，`use strict`;
- 关键字和保留字。使用关键字会引起 `Identifier Expected` 错误；
- 变量，全局变量和局部变量。

### 数据类型
有六种基本的数据类型：

`underfined, null, Boolean, Number, String, Object`

#### 检测数据类型
`typeof `操作符，检测结果如下：

| 类型         | 结果         |
|--------------|--------------|
| underfined   | 'underfined' |
| Boolean      | 'boolean'    |
| String       | 'string'     |
| Number       | 'number'     |
| Object, null | 'object'     |
| function     | 'function'   |

单独的列出了函数的检测结果。六种基本数据类型当中的 null 合并到 object 中了，因为 null 本身就是一个空对象指针。

#### underfined 类型
注意变量未初始化的结果是 underfined 类型。

使用 typeof 检测未声明的变量时仍然会显示 underfined 类型，注意区分。

#### null 类型
一定注意，null 是一个**空对象指针**。

一般定义一个变量准备保存对象时，最好首先将其初始化为 null。这样，可以直接检测 null 值就可以判断这个变量是否已经保存了一个对象的引用。

#### Boolean 类型
区分大小写，只有小写才表示正常的真，假值。

转型函数 `Boolean()`:
| 数据类型   | 真值       | 假值   |
| string     | 非空字符串 | 空     |
| number     | 非零       | 0和NaN |
| object     | 任何对象   | null   |
| underfined | 没有       | 本身   |

#### Number 类型
ECMAScript 使用 IEEE754（二进制浮点数计算标准）保存所有的数字类型为浮点数，采用64位双精度的格式。其中，0-51位表示数字，52-62表示指数，代表小数点的位置，63位是正负号的位置。因此，小数的最高精度是17位。

- [ ] 17位有效数字的详细原因。

[数字在JavaScript中是如何编译的](https://segmentfault.com/a/1190000014867071) 

著名的问题：
> 0.1+0.2!=0.3 

这是因为 0.1 和 0.2 都不能完全的化简为二进制，然后相加后也没办法化简。在最高精度内存在数字，因此，JS 不认为这个结果和 0.3 相等。这是采用 IEEE754 标准的所有语言的问题。

```javascript
0.1+0.2
0.30000000000000004
```

十进制和二进制小数的转换，负数的转换。

存储单位：64位(bit) = 8 字节(byte), 1 KB=1024 byte. 说的汉字属于宽字符，双字节的，就是这个意思。

- 浮点数，浮点数的占用内存是整数值的两倍，所以 JS 会自动的转为整数；
- 数值范围，存在一个 `Infinity, -Infinity` 范围，可以使用 `Number.MIN_VALUE` 属性查看，可以使用 `isFinte()` 来判断一个数是否在有效范围内，是返回真。
- NaN，not a number, 表示本该返回数值的操作结果并未返回数值的情况。任何数除以 0 就会出现这种结果。任何设计 Nan 的计算结果都是 NaN, NaN 与任何值都不相等，包括本身。

	可以使用 `isNaN()` 函数来判断是不是正确数值。可以传入字符串（思考一下结果），对象（思考一下过程）。

---
*一个比较重要的问题: 数值转换问题* 

| `Number()`                     | `parseInt()`                           | `parseFloat()`   |
|--------------------------------|----------------------------------------|------------------|
| 多种类型                       | 仅限于字符串                           | 仅限于字符串     |
| 识别正负号，小数点，和空字符串 | 只识别以数字开头的字符串，不支持小数点 | 改进，支持小数点 |

`number()` 函数在多种类型时的处理：

| 数值类型                          | 结果           |
|-----------------------------------|----------------|
| boolean                           | 1,0            |
| number                            | 简单的传入传出 |
| null                              | 0              |
| underfined                        | NaN            |
| string                            |                |
| -- 正负号，小数点，进制，空字符串 | 正常识别       |
| -- 有不认识的，`12bule`           | NaN            |
| Object                            | 正常对象的处理 |

`parseInt()` 函数的特点：

**工作机制**：从字符串开头开始，忽略开头的空格，如果开头第一个非空字符不是数字或者正负号，直接返回 NaN。如果找到第一个数字，就会继续向后找，直至不是数字为止。

一个例子，`123 1blue` 返回 123，不会去掉空格，不会识别字母，不是数字直接退出。

不识别小数点。

可以提供第二个参数, 作为进制的指示，可以传入一个 Number 数值，表明返回结果的进制。

`parseFloat()` 函数：

改进版的 `parseInt()`, 识别小数了。只识别第一个小数点。

不支持基数(就是第二个参数)。另外，输入也只支持十进制，十六进制为返回0。

### string 类型
1. 字符字面量，就是一些特殊的字符。

| 字面量 | 含义         |
|--------|--------------|
| \n     |              |
| \t     |              |
| \b     |              |
| \r     |              |
| \xnn   | 十六进制     |
| \unnnn | unicode 字符 |

2. 字符串是不可变的。如果要更改，只能先删除，再重新赋值。这个部分已经浏览器默认做了。

3. 转换为字符串

`toString()` 任何数据类型除了 null 和 underfined，都有这个**方法**, 对于数值对象，还可以传递一个基数，返回相应进制的结果。

`String()` 加强版的 `toString()`, 正确返回 null 和 underfined。

###  Object 类型
对象就是一组数据和功能的集合。

每个对象都有以下属性和方法：

| 值                       | 含义                                         | 备注 |
|--------------------------|----------------------------------------------|------|
| `constructor`            | 构造函数                                     |      |
| `hasOwnProperty(string)` | 检查属性是否存在                             |      |
| `isPrototypeof(object)`  | 检查传入的对象是不是传入对象的原型           | *    |
| `propertyEnumberable()`  | 检查属性是不是一个迭代器，可以用 for-in 语句 |      |
| `toLocalString()`        |                                              |      |
| `toString()`             | 当对象转为字符串时调用的函数                 |      |
| `valueOf()`              | 返回对象的字符串，数值或布尔值表述           |      |


